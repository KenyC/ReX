\documentclass{article}\usepackage{unicode-math}\setmathfont{xits-math.otf}\begin{document}\[ \int_0^\infty \]\end{document}

\documentclass{article}\usepackage{unicode-math}\setmathfont{xits-math.otf}\begin{document}\[ \int_0^\infty \]\end{document}

Atom Change rules:

- Ignore Kerning on list.
- Left and Right Atom type.
- Transparent recursion.


# Notes

- Only binary types are mutable.
- Change binary -> ordinal.
- No differences between binary and ordinal for layout other than kerning.
  `- scripts are same, accents are same, etc..
- Mutation of binary depends strictly on neighboring elements.

# Sketch of top down tree walk

[sym] [Color: [kern][op]] [sym]    

sym -                       - (previous op) sym
    (Previous sym), kern, op

# If first or last item is a Bin, change it to an Ordinal.
 `- before recursive algorithm, start with phantom Bin atom-type.
 `- Question: How to determine end of list while nested?
      pass a last boolean in recursion?

# If Bin and Previous in { ... }, Bin -> Ord.
 `- Send previous atom_type in recursion, and keep atom_type while iterating.
    - def recurse(last_atom): for node in parse_nodes: check; last_atom = current;
 `- Current atom_type changes. Will not change again.  Can place space between
    previous atom.  Just change last_atom to new atom type now.

    def recurse(last_atom):
        for node in nodes:
            
# If { ... } and prev is Bin, Prev -> Ord.
 `- This means that for Binaries that have not changed, may change, and so can't
    place kerning yet.
 `- Can change this rule to:
    if Binary and Next in {Rel, Close, Punct}: change Bin to Ordinal.

    // Start with phantom types that will trigger start/end of lists.
    Init: recurse(Binary, Punct);
    def recurse(prev_atom, parent_next):
        for node in nodes:
            next = if idx + 1 < len { nodes[idx+1] } else { parent_next }
            
            // Make necessary atom modifications and add spacing.
            if node.type == Binary:
                if prev_atom in { Bin, Op, Rel, Open, Punct }:
                    layout.add(spacing)
                    prev_atom = Ordinal
                else if next in { Rel, Close, Punct }:
                    layout.add(spacing)
                    prev_atom = Ordinal

                // No modifications were necessary
                else:
                    layout.add(spacing)
                    prev_atom = Binary;
            else:
                layout.add(spacing)
                prev_atom = node.type

# This previous algorithm requires for use to be able to determine 
  the atom type of the current node.  Unless it's a wrapper type, then
  recurse.
  
  The above algorithm only really needs to be triggered in two scenarios:
    `- Symbol with atom_type Binary.
    `- AtomChange with atom_type Binary.
    
  We can change the code so that each parse node takes care of their own handling
  of the atom types, since only these two require special logic.


[sym] [Color: [kern][op]] [sym]
    

    


# Scripts algorithm variations

## Accents 
    - influences vertical height calculation.
    - only by redefining the height of the base, if only a symbol.

## Operators 
    (a) Limits:   Branch to new specialized algorithm.
    (b) Nolimits: Influences the horizontal kerning of the limits.

## Symbols
    - Influences the horizontal kerning of the limits.

Sub-routines for scripts:

 - Check if base is an operator.

ParseNode:
fn atom_type(&self) -> AtomType {
    match *self {
        Symbol(ref sym) => sym.atom_type,
        Delimited(_)    => AtomType::Inner,
        Radical(_)      => AtomType::Alpha,
        Fraction(_)     => AtomType::Inner,
        Group(_)        => AtomType::Alpha,
        Scripts(ref scr) => {
            if let Some(ref base) = scr.base {
                base.atom_type()
            } else {
                AtomType::Alpha
            }
        }
        Rule            => AtomType::Alpha,
        Kerning         => AtomType::Transparent,
        Accent(ref acc) => {
            if let Some(ref base) = acc.nucleus {
                base.atom_type()
            } else {
                AtomType::Alpha,
            }
        }
        Style              => AtomType::Transparent,
        AtomChange(ref ac) => ac.atom_type,
        Color(ref clr)     => {
            if let Some(ref node) = clr.inner.first() {
                node.atom_type()
            } else {
                AtomType::Alpha
            }
        }
    }
}

impl HasAtomType for Delimited:
fn atom_type(&self) -> AtomType {
    // return the atom-type of the left delimiter, 
    // otherwise return the atom_type of the first inner.
    
}
