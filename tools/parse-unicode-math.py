#!/bin/python
from collections import defaultdict

symbols = []
header = """\
// DO NOT MODIFY!  
//
// This file is automatically generated by the ../tools/parse-unicode-math.py file using the
// unicode-math-table.tex file taken from `unicode-math` on CTAN. If you find a bug
// in this file, please modify ../tools/parse-unicode-math.py accordingly instead.
//
// FIXME: We should probably use the official unicode standards source.

#![allow(dead_code)]
use phf;
use parsenodes::AtomType;
use symbols::Symbol;

pub static SYMBOLS: phf::Map<&'static str, Symbol> = phf_map! {
"""

# Convert ../unicode-math-table.tex atomtype to our AtomType.
convert_type = {
    "mathalpha": "Alpha",
    "mathpunct": "Punctuation",
    "mathopen": "Open",
    "mathclose": "Close",
    "mathord": "Ordinal",
    "mathbin": "Binary",
    "mathrel": "Relation",
    "mathop": "Operator",
    "mathfence": "Fence",
    "mathover": "Over",
    "mathunder": "Under",
    "mathaccent": "Accent",
    "mathaccentwide": "AccentWide",
    "mathbotaccent": "BotAccent",
    "mathbotaccentwide": "BotAccentWide",
}

# TeX -> Unicode template
template = '    "{}" => Symbol {{ code: {}, atom_type: AtomType::{} }}, // {}\n'

# Parse 'unicode-math-table.tex'.  Store relavent information in
# `symbols` as 4-tuples:
#     (TeX command, Unicode, AtomType, Description)
with open('unicode-math-table.tex', 'r') as f:
    for line in f:
        code = "0x" + line[20:25]
        cmd  = line[28:53].strip()

        cursor = 56
        while line[cursor] != '}': cursor += 1
        atom = line[56:cursor]

        cursor += 2  # Skip next `}{` sequence
        desc = line[cursor:-3]

        symbols.append((cmd, code, convert_type[atom], desc))

# Write '.../syc/symbols.rs'
with open('../src/symbols/table.rs', 'w') as f:
    f.write(header)
    # Write TeX Command -> Symbol hashmap.
    for tpl in symbols:
        f.write(template.format(*tpl))
    f.write('};')

# The following is scratch work, kept in case it's need later

# This list is sorted, ordered by code point.
# Print the distribution of code points
# Starting from first, to last.
# collisions = defaultdict(set)
# previous   = [0,"0"]
# output = ""

# for symbol in symbols:
#     code          = int(symbol[1], 0)
#     previous_code = int(previous[1], 0)

#     # We have found a collision
#     if code == previous_code:
#         collisions[code].update([symbol, previous])
    
#     # No collision, so count how far we've gone and print out symbols
#     else:
#         output += '.'*(code - previous_code - 1) + '#'
#         previous = symbol

# This output is being used for helping me determine how to group
# the unicode points for when creating a map from unicode -> atom type.
# The groups still need to be figured out.
#
# . means there is no atom-type and # means the is.
#
# with open('dist.txt', 'w') as f:
#    f.write(output)
# print(output)
# print("\n")

# Use this to determine the collisions from unicode -> atom type.
# print(collisions)

# Default values for symbols that have multiple TeX commands.
# Currently only accents collide with Accent vs AccentWide.
# We will choose AccentWide by default, but I don't think it's
# likely people will manually input combining characters.

# collision_defaults = {
#     "0x020D0": "AccentWide",
#     "0x020D1": "AccentWide",
#     "0x00302": "AccentWide",
#     "0x00303": "AccentWide",
#     "0x020D7": "AccentWide",
# }

# The following table gives offsets to the code point for various styles.
# This will be need to convert input code points to the proper math font
# code points.

# *         -> 0x2217  //  Centered asterisk
# 

# A...Za...z           // Substract 6 from 'a' to make A...Za...z adjacent
#                      // Substract 0x41 to find offset from A
# mbf       -> 0x1D400 // Math Bold
# mit       -> 0x1D434 // Math Italic
# mbfit     -> 0x1D468 // Math Bold Italic
# mscr      -> 0x1D49C // Math Script
# mbfscr    -> 0x1D4D0 // Math Bold Script
# mfrak     -> 0x1D504 // Math Fraktur
# Bbb       -> 0x1D538 // Math double-struck
# mbffrak   -> 0x1D56C // Math Bold Fraktur
# msans     -> 0x1D5A0 // Math Sans-serif
# mbfsans   -> 0x1D5D4 // Math Bold Sans-serif
# mitsans   -> 0x1D608 // Math Italic Sans-serif
# mbfitsans -> 0x1D63C // Math Bold Italic Sans-serif
# mtt       -> 0x1D670 // Math Monospace

# Greek: 0391-03C9      // Lots of gaps here
# mbf       -> 0x1D6A8  // Greek Bold
# mit       -> 0x1D6E2  // Greek italic
# mbfit     -> 0x1D71C  // Greek Bold Italic
# mbfsans   -> 0x1D756  // Greek Bold Sans-serif
# mbfitsans -> 0x1D790  // Greek Bold Italic Sans-serif

# 0..9                  // Subtract by 0x30 to get relative offset
# mbf       -> 0x1D7CE  // Math Bold Digit
# Bbb       -> 0x1D7D8  // Math doube-struck Digit
# msans     -> 0x1D7E2  // Math Sans-serif Digit
# mbfsans   -> 0x1D7EC  // Math Bold Sans-serif Digit
# mtt       -> 0x1D7F6  // Math Monospace Digit

# Recognize
# ----------
# Binary    -> *+
# Open      -> ([
# Close     -> )]?!
# Relative  -> =<>:
# Punct     -> ,;
# Ord       -> |a...zA...Z0123456789/@."