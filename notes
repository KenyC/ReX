Accents:

The top_accent value represents a vertical line somewhere in the accentee. The accent will be shifted horizontally such that its own top_accent line coincides with the one from the accentee.

Fallback: If the top_accent value of the accent is zero, then half the width of the accent followed by its italic correction is used instead.

BottomAccent: The vertical placement of a bottom accent is straight below the accentee, no correction takes place.

struct LayoutNode {
    node:   LayoutVariant,
    width:  Pixels,  // This is the advance value for glyphs
    height: Pixels,
    depth:  Pixels,
}

// Note, some nodes require knowing the width of the parent box.
// for instance, centering fractions. `\center`.
// For fractions this can be handled while setting up the layout of
// both the numerator and denominator, and centering afterwards.
//
// A more general technique would be:
//   (1) Given an hbox of size L, center contents of hbox.
//       - Setup HBox, assign the desired width
//       then either:
//          (a) Give a flag to hbox to align contents (hand off to renderer)
//          (b) place appropriate kerning in hbox contents.
//          Leaning towards (a), but (b) will probably be more efficent.
//
// Both HorizontalBox and VerticalBox seem identical with the exception for:
//     - Displacement does something different (perp to direction)
//     - Layout direction is changed.
//     Merge? Probably not.



struct HorizontalBox {
    contents:     Vec<LayoutNodes>,    
    displacement: Pixels,
}

struct VerticalBox {
    contents:     Vect<LayoutNode>,
    displacement: Pixels,
}

struct Glyph {
    unicode:    u32,
    

// ParseNodes need an easy `is_character()` method.

// AtomType bit flags:

AtomType
    0x8 bits:
    0 = ord, 1 = op, 2 = bin, 3 = rel, 
    4 = open, 5 = close, 7 = punc, 8 = inner
    
    0x10 - Display Limits if set.
    0x30 - Accent Below if set. 
    0x80 - Transparent



// Simple box paint
struct Rule {
    Style: Color? Solid fill? Border? What to do? Invisible?
}

impl Deref for HorizontalBox {
    fn deref(&self) -> &[LayoutNode] { &self.contents }
}
